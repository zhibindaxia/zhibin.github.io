#Volatile

比较并交换
* java虚拟机提供的轻量级的同步机制
   * 保证可见性
   * 不保证原子性
   * 禁止指令重排(有序性)

##JMM(Java内存模型)
它是一个抽象概念,只是一组规则或规范

### JMM数据原子操作
![Alt text](./1596591356548.png)

###JMM线程内存模型
![Alt text](https://github.com/zhibindaxia/zhibin.github.io/blob/master/java%E5%9F%BA%E7%A1%80/JMM%E5%86%85%E5%AD%98%E6%A8%A1%E5%9E%8B%E5%9B%BE.png)
* 获取数据过程: read -> load -> use
* 修改数据过程: assign->store(已经在主内存中,但是还未更新值) ->write
* 加锁演化:
	* 早期加锁方式: **总线加锁**,它的性能太低,cpu从主内存读取数据到高速缓存过程中,会在总线对这个数据加锁,这样其他CPU就没法去读或写这个数据,直到这个CPU使用完数据释放锁之后其他CPU才能读取该数据.
	* 现在使用**MESI缓存一致性协议**,多个CPU从主内存读取同一个数据到各自的高速缓存,当其中某个CPU修改了缓存里的数据,该数据会马上同步回主内存,其他CPU通过**总线嗅探机制**(通过监听store过程,store过程经过总线的瞬间)可以感知到数据的变化,**从而将自己的缓存里的数据失效**.
		


##运行速度差距

硬盘<内存<CPU

CPU与内存之间存在缓存cache
