#Volatile
* java虚拟机提供的轻量级的同步机制
   * 保证可见性
   * 不保证原子性
   * 禁止指令重排(有序性)

##JMM(Java内存模型)
它是一个抽象概念,只是一组规则或规范

### JMM数据原子操作
![Alt text](./1596591356548.png)

###JMM线程内存模型
![Alt text](./1596591533068.png)
* 获取数据过程: read -> load -> use
* 修改数据过程: assign->store(已经在主内存中,但是还未更新值) ->write
* 加锁演化:
	* 早期加锁方式: **总线加锁**,它的性能太低,cpu从主内存读取数据到高速缓存过程中,会在总线对这个数据加锁,这样其他CPU就没法去读或写这个数据,直到这个CPU使用完数据释放锁之后其他CPU才能读取该数据.
	* 现在使用**MESI缓存一致性协议**,多个CPU从主内存读取同一个数据到各自的高速缓存,当其中某个CPU修改了缓存里的数据,该数据会马上同步回主内存,其他CPU通过**总线嗅探机制**(通过监听store过程,store过程经过总线的瞬间)可以感知到数据的变化,**从而将自己的缓存里的数据失效**.
		


##运行速度差距

硬盘<内存<CPU

CPU与内存之间存在缓存cache

##指令重排

* 要考虑数据依赖性 
* 编译器优化重排
* 内存屏障(内存栅栏),CPU指令,作用有两个  (即上面所说的 store和load)
	* 一是保证特定操作的执行顺序
	* 二是保证某些变量的内存可见性
